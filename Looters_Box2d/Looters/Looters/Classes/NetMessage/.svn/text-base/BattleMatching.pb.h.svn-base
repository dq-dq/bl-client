// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BattleMatching.proto

#ifndef PROTOBUF_BattleMatching_2eproto__INCLUDED
#define PROTOBUF_BattleMatching_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BattleMatching_2eproto();
void protobuf_AssignDesc_BattleMatching_2eproto();
void protobuf_ShutdownFile_BattleMatching_2eproto();

class BattleMatchingRequest;
class BattleMatchingResponse;
class BattleMatchingResponse_UserMapData;
class BattleMatchingResponse_UserMapData_Clans;
class BattleMatchingResponse_AttackerSoldiersAndSpell;
class BattleMatchingResponse_BuildDestoryStatus;

// ===================================================================

class BattleMatchingRequest : public ::google::protobuf::MessageLite {
 public:
  BattleMatchingRequest();
  virtual ~BattleMatchingRequest();
  
  BattleMatchingRequest(const BattleMatchingRequest& from);
  
  inline BattleMatchingRequest& operator=(const BattleMatchingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BattleMatchingRequest& default_instance();
  
  void Swap(BattleMatchingRequest* other);
  
  // implements Message ----------------------------------------------
  
  BattleMatchingRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleMatchingRequest& from);
  void MergeFrom(const BattleMatchingRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mailAddress = 1;
  inline bool has_mailaddress() const;
  inline void clear_mailaddress();
  static const int kMailAddressFieldNumber = 1;
  inline const ::std::string& mailaddress() const;
  inline void set_mailaddress(const ::std::string& value);
  inline void set_mailaddress(const char* value);
  inline void set_mailaddress(const char* value, size_t size);
  inline ::std::string* mutable_mailaddress();
  inline ::std::string* release_mailaddress();
  
  // optional string previousMailAddress = 2;
  inline bool has_previousmailaddress() const;
  inline void clear_previousmailaddress();
  static const int kPreviousMailAddressFieldNumber = 2;
  inline const ::std::string& previousmailaddress() const;
  inline void set_previousmailaddress(const ::std::string& value);
  inline void set_previousmailaddress(const char* value);
  inline void set_previousmailaddress(const char* value, size_t size);
  inline ::std::string* mutable_previousmailaddress();
  inline ::std::string* release_previousmailaddress();
  
  // optional string str_md5 = 3;
  inline bool has_str_md5() const;
  inline void clear_str_md5();
  static const int kStrMd5FieldNumber = 3;
  inline const ::std::string& str_md5() const;
  inline void set_str_md5(const ::std::string& value);
  inline void set_str_md5(const char* value);
  inline void set_str_md5(const char* value, size_t size);
  inline ::std::string* mutable_str_md5();
  inline ::std::string* release_str_md5();
  
  // optional int32 battle_status = 4;
  inline bool has_battle_status() const;
  inline void clear_battle_status();
  static const int kBattleStatusFieldNumber = 4;
  inline ::google::protobuf::int32 battle_status() const;
  inline void set_battle_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:message.BattleMatchingRequest)
 private:
  inline void set_has_mailaddress();
  inline void clear_has_mailaddress();
  inline void set_has_previousmailaddress();
  inline void clear_has_previousmailaddress();
  inline void set_has_str_md5();
  inline void clear_has_str_md5();
  inline void set_has_battle_status();
  inline void clear_has_battle_status();
  
  ::std::string* mailaddress_;
  ::std::string* previousmailaddress_;
  ::std::string* str_md5_;
  ::google::protobuf::int32 battle_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_BattleMatching_2eproto();
  friend void protobuf_AssignDesc_BattleMatching_2eproto();
  friend void protobuf_ShutdownFile_BattleMatching_2eproto();
  
  void InitAsDefaultInstance();
  static BattleMatchingRequest* default_instance_;
};
// -------------------------------------------------------------------

class BattleMatchingResponse_UserMapData_Clans : public ::google::protobuf::MessageLite {
 public:
  BattleMatchingResponse_UserMapData_Clans();
  virtual ~BattleMatchingResponse_UserMapData_Clans();
  
  BattleMatchingResponse_UserMapData_Clans(const BattleMatchingResponse_UserMapData_Clans& from);
  
  inline BattleMatchingResponse_UserMapData_Clans& operator=(const BattleMatchingResponse_UserMapData_Clans& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BattleMatchingResponse_UserMapData_Clans& default_instance();
  
  void Swap(BattleMatchingResponse_UserMapData_Clans* other);
  
  // implements Message ----------------------------------------------
  
  BattleMatchingResponse_UserMapData_Clans* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleMatchingResponse_UserMapData_Clans& from);
  void MergeFrom(const BattleMatchingResponse_UserMapData_Clans& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 character_id = 1;
  inline bool has_character_id() const;
  inline void clear_character_id();
  static const int kCharacterIdFieldNumber = 1;
  inline ::google::protobuf::int32 character_id() const;
  inline void set_character_id(::google::protobuf::int32 value);
  
  // optional int32 character_level = 2;
  inline bool has_character_level() const;
  inline void clear_character_level();
  static const int kCharacterLevelFieldNumber = 2;
  inline ::google::protobuf::int32 character_level() const;
  inline void set_character_level(::google::protobuf::int32 value);
  
  // optional int32 finished_produce_count = 3;
  inline bool has_finished_produce_count() const;
  inline void clear_finished_produce_count();
  static const int kFinishedProduceCountFieldNumber = 3;
  inline ::google::protobuf::int32 finished_produce_count() const;
  inline void set_finished_produce_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:message.BattleMatchingResponse.UserMapData.Clans)
 private:
  inline void set_has_character_id();
  inline void clear_has_character_id();
  inline void set_has_character_level();
  inline void clear_has_character_level();
  inline void set_has_finished_produce_count();
  inline void clear_has_finished_produce_count();
  
  ::google::protobuf::int32 character_id_;
  ::google::protobuf::int32 character_level_;
  ::google::protobuf::int32 finished_produce_count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_BattleMatching_2eproto();
  friend void protobuf_AssignDesc_BattleMatching_2eproto();
  friend void protobuf_ShutdownFile_BattleMatching_2eproto();
  
  void InitAsDefaultInstance();
  static BattleMatchingResponse_UserMapData_Clans* default_instance_;
};
// -------------------------------------------------------------------

class BattleMatchingResponse_UserMapData : public ::google::protobuf::MessageLite {
 public:
  BattleMatchingResponse_UserMapData();
  virtual ~BattleMatchingResponse_UserMapData();
  
  BattleMatchingResponse_UserMapData(const BattleMatchingResponse_UserMapData& from);
  
  inline BattleMatchingResponse_UserMapData& operator=(const BattleMatchingResponse_UserMapData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BattleMatchingResponse_UserMapData& default_instance();
  
  void Swap(BattleMatchingResponse_UserMapData* other);
  
  // implements Message ----------------------------------------------
  
  BattleMatchingResponse_UserMapData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleMatchingResponse_UserMapData& from);
  void MergeFrom(const BattleMatchingResponse_UserMapData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef BattleMatchingResponse_UserMapData_Clans Clans;
  
  // accessors -------------------------------------------------------
  
  // optional int32 map_index_x = 1;
  inline bool has_map_index_x() const;
  inline void clear_map_index_x();
  static const int kMapIndexXFieldNumber = 1;
  inline ::google::protobuf::int32 map_index_x() const;
  inline void set_map_index_x(::google::protobuf::int32 value);
  
  // optional int32 uniqueness_build_id = 2;
  inline bool has_uniqueness_build_id() const;
  inline void clear_uniqueness_build_id();
  static const int kUniquenessBuildIdFieldNumber = 2;
  inline ::google::protobuf::int32 uniqueness_build_id() const;
  inline void set_uniqueness_build_id(::google::protobuf::int32 value);
  
  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional int32 building_id = 4;
  inline bool has_building_id() const;
  inline void clear_building_id();
  static const int kBuildingIdFieldNumber = 4;
  inline ::google::protobuf::int32 building_id() const;
  inline void set_building_id(::google::protobuf::int32 value);
  
  // optional int32 Building_level = 5;
  inline bool has_building_level() const;
  inline void clear_building_level();
  static const int kBuildingLevelFieldNumber = 5;
  inline ::google::protobuf::int32 building_level() const;
  inline void set_building_level(::google::protobuf::int32 value);
  
  // optional int32 map_index_y = 6;
  inline bool has_map_index_y() const;
  inline void clear_map_index_y();
  static const int kMapIndexYFieldNumber = 6;
  inline ::google::protobuf::int32 map_index_y() const;
  inline void set_map_index_y(::google::protobuf::int32 value);
  
  // repeated .message.BattleMatchingResponse.UserMapData.Clans clansList = 7;
  inline int clanslist_size() const;
  inline void clear_clanslist();
  static const int kClansListFieldNumber = 7;
  inline const ::message::BattleMatchingResponse_UserMapData_Clans& clanslist(int index) const;
  inline ::message::BattleMatchingResponse_UserMapData_Clans* mutable_clanslist(int index);
  inline ::message::BattleMatchingResponse_UserMapData_Clans* add_clanslist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData_Clans >&
      clanslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData_Clans >*
      mutable_clanslist();
  
  // optional int32 collect_count = 8;
  inline bool has_collect_count() const;
  inline void clear_collect_count();
  static const int kCollectCountFieldNumber = 8;
  inline ::google::protobuf::int32 collect_count() const;
  inline void set_collect_count(::google::protobuf::int32 value);
  
  // optional int32 second_elixir_count = 9;
  inline bool has_second_elixir_count() const;
  inline void clear_second_elixir_count();
  static const int kSecondElixirCountFieldNumber = 9;
  inline ::google::protobuf::int32 second_elixir_count() const;
  inline void set_second_elixir_count(::google::protobuf::int32 value);
  
  // optional int32 building_status = 10;
  inline bool has_building_status() const;
  inline void clear_building_status();
  static const int kBuildingStatusFieldNumber = 10;
  inline ::google::protobuf::int32 building_status() const;
  inline void set_building_status(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:message.BattleMatchingResponse.UserMapData)
 private:
  inline void set_has_map_index_x();
  inline void clear_has_map_index_x();
  inline void set_has_uniqueness_build_id();
  inline void clear_has_uniqueness_build_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_building_id();
  inline void clear_has_building_id();
  inline void set_has_building_level();
  inline void clear_has_building_level();
  inline void set_has_map_index_y();
  inline void clear_has_map_index_y();
  inline void set_has_collect_count();
  inline void clear_has_collect_count();
  inline void set_has_second_elixir_count();
  inline void clear_has_second_elixir_count();
  inline void set_has_building_status();
  inline void clear_has_building_status();
  
  ::google::protobuf::int32 map_index_x_;
  ::google::protobuf::int32 uniqueness_build_id_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 building_id_;
  ::google::protobuf::int32 building_level_;
  ::google::protobuf::int32 map_index_y_;
  ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData_Clans > clanslist_;
  ::google::protobuf::int32 collect_count_;
  ::google::protobuf::int32 second_elixir_count_;
  ::google::protobuf::int32 building_status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_BattleMatching_2eproto();
  friend void protobuf_AssignDesc_BattleMatching_2eproto();
  friend void protobuf_ShutdownFile_BattleMatching_2eproto();
  
  void InitAsDefaultInstance();
  static BattleMatchingResponse_UserMapData* default_instance_;
};
// -------------------------------------------------------------------

class BattleMatchingResponse_AttackerSoldiersAndSpell : public ::google::protobuf::MessageLite {
 public:
  BattleMatchingResponse_AttackerSoldiersAndSpell();
  virtual ~BattleMatchingResponse_AttackerSoldiersAndSpell();
  
  BattleMatchingResponse_AttackerSoldiersAndSpell(const BattleMatchingResponse_AttackerSoldiersAndSpell& from);
  
  inline BattleMatchingResponse_AttackerSoldiersAndSpell& operator=(const BattleMatchingResponse_AttackerSoldiersAndSpell& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BattleMatchingResponse_AttackerSoldiersAndSpell& default_instance();
  
  void Swap(BattleMatchingResponse_AttackerSoldiersAndSpell* other);
  
  // implements Message ----------------------------------------------
  
  BattleMatchingResponse_AttackerSoldiersAndSpell* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleMatchingResponse_AttackerSoldiersAndSpell& from);
  void MergeFrom(const BattleMatchingResponse_AttackerSoldiersAndSpell& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 characterIdOrSpellId = 1;
  inline bool has_characteridorspellid() const;
  inline void clear_characteridorspellid();
  static const int kCharacterIdOrSpellIdFieldNumber = 1;
  inline ::google::protobuf::int32 characteridorspellid() const;
  inline void set_characteridorspellid(::google::protobuf::int32 value);
  
  // optional int32 characterOrSpellLevel = 2;
  inline bool has_characterorspelllevel() const;
  inline void clear_characterorspelllevel();
  static const int kCharacterOrSpellLevelFieldNumber = 2;
  inline ::google::protobuf::int32 characterorspelllevel() const;
  inline void set_characterorspelllevel(::google::protobuf::int32 value);
  
  // optional int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // optional int32 used_type = 4;
  inline bool has_used_type() const;
  inline void clear_used_type();
  static const int kUsedTypeFieldNumber = 4;
  inline ::google::protobuf::int32 used_type() const;
  inline void set_used_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:message.BattleMatchingResponse.AttackerSoldiersAndSpell)
 private:
  inline void set_has_characteridorspellid();
  inline void clear_has_characteridorspellid();
  inline void set_has_characterorspelllevel();
  inline void clear_has_characterorspelllevel();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_used_type();
  inline void clear_has_used_type();
  
  ::google::protobuf::int32 characteridorspellid_;
  ::google::protobuf::int32 characterorspelllevel_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 used_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_BattleMatching_2eproto();
  friend void protobuf_AssignDesc_BattleMatching_2eproto();
  friend void protobuf_ShutdownFile_BattleMatching_2eproto();
  
  void InitAsDefaultInstance();
  static BattleMatchingResponse_AttackerSoldiersAndSpell* default_instance_;
};
// -------------------------------------------------------------------

class BattleMatchingResponse_BuildDestoryStatus : public ::google::protobuf::MessageLite {
 public:
  BattleMatchingResponse_BuildDestoryStatus();
  virtual ~BattleMatchingResponse_BuildDestoryStatus();
  
  BattleMatchingResponse_BuildDestoryStatus(const BattleMatchingResponse_BuildDestoryStatus& from);
  
  inline BattleMatchingResponse_BuildDestoryStatus& operator=(const BattleMatchingResponse_BuildDestoryStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BattleMatchingResponse_BuildDestoryStatus& default_instance();
  
  void Swap(BattleMatchingResponse_BuildDestoryStatus* other);
  
  // implements Message ----------------------------------------------
  
  BattleMatchingResponse_BuildDestoryStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleMatchingResponse_BuildDestoryStatus& from);
  void MergeFrom(const BattleMatchingResponse_BuildDestoryStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 building_id = 1;
  inline bool has_building_id() const;
  inline void clear_building_id();
  static const int kBuildingIdFieldNumber = 1;
  inline ::google::protobuf::int32 building_id() const;
  inline void set_building_id(::google::protobuf::int32 value);
  
  // optional int32 uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline ::google::protobuf::int32 uuid() const;
  inline void set_uuid(::google::protobuf::int32 value);
  
  // optional int32 map_index_x = 3;
  inline bool has_map_index_x() const;
  inline void clear_map_index_x();
  static const int kMapIndexXFieldNumber = 3;
  inline ::google::protobuf::int32 map_index_x() const;
  inline void set_map_index_x(::google::protobuf::int32 value);
  
  // optional int32 map_index_y = 4;
  inline bool has_map_index_y() const;
  inline void clear_map_index_y();
  static const int kMapIndexYFieldNumber = 4;
  inline ::google::protobuf::int32 map_index_y() const;
  inline void set_map_index_y(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:message.BattleMatchingResponse.BuildDestoryStatus)
 private:
  inline void set_has_building_id();
  inline void clear_has_building_id();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_map_index_x();
  inline void clear_has_map_index_x();
  inline void set_has_map_index_y();
  inline void clear_has_map_index_y();
  
  ::google::protobuf::int32 building_id_;
  ::google::protobuf::int32 uuid_;
  ::google::protobuf::int32 map_index_x_;
  ::google::protobuf::int32 map_index_y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_BattleMatching_2eproto();
  friend void protobuf_AssignDesc_BattleMatching_2eproto();
  friend void protobuf_ShutdownFile_BattleMatching_2eproto();
  
  void InitAsDefaultInstance();
  static BattleMatchingResponse_BuildDestoryStatus* default_instance_;
};
// -------------------------------------------------------------------

class BattleMatchingResponse : public ::google::protobuf::MessageLite {
 public:
  BattleMatchingResponse();
  virtual ~BattleMatchingResponse();
  
  BattleMatchingResponse(const BattleMatchingResponse& from);
  
  inline BattleMatchingResponse& operator=(const BattleMatchingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BattleMatchingResponse& default_instance();
  
  void Swap(BattleMatchingResponse* other);
  
  // implements Message ----------------------------------------------
  
  BattleMatchingResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleMatchingResponse& from);
  void MergeFrom(const BattleMatchingResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef BattleMatchingResponse_UserMapData UserMapData;
  typedef BattleMatchingResponse_AttackerSoldiersAndSpell AttackerSoldiersAndSpell;
  typedef BattleMatchingResponse_BuildDestoryStatus BuildDestoryStatus;
  
  // accessors -------------------------------------------------------
  
  // optional sint32 result = 1 [default = 0];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // optional string defencer_mailaddress = 3;
  inline bool has_defencer_mailaddress() const;
  inline void clear_defencer_mailaddress();
  static const int kDefencerMailaddressFieldNumber = 3;
  inline const ::std::string& defencer_mailaddress() const;
  inline void set_defencer_mailaddress(const ::std::string& value);
  inline void set_defencer_mailaddress(const char* value);
  inline void set_defencer_mailaddress(const char* value, size_t size);
  inline ::std::string* mutable_defencer_mailaddress();
  inline ::std::string* release_defencer_mailaddress();
  
  // optional string nick_name = 4;
  inline bool has_nick_name() const;
  inline void clear_nick_name();
  static const int kNickNameFieldNumber = 4;
  inline const ::std::string& nick_name() const;
  inline void set_nick_name(const ::std::string& value);
  inline void set_nick_name(const char* value);
  inline void set_nick_name(const char* value, size_t size);
  inline ::std::string* mutable_nick_name();
  inline ::std::string* release_nick_name();
  
  // optional int32 golden_count = 5;
  inline bool has_golden_count() const;
  inline void clear_golden_count();
  static const int kGoldenCountFieldNumber = 5;
  inline ::google::protobuf::int32 golden_count() const;
  inline void set_golden_count(::google::protobuf::int32 value);
  
  // optional int32 elixir_count = 6;
  inline bool has_elixir_count() const;
  inline void clear_elixir_count();
  static const int kElixirCountFieldNumber = 6;
  inline ::google::protobuf::int32 elixir_count() const;
  inline void set_elixir_count(::google::protobuf::int32 value);
  
  // optional int32 pvp_mark = 7;
  inline bool has_pvp_mark() const;
  inline void clear_pvp_mark();
  static const int kPvpMarkFieldNumber = 7;
  inline ::google::protobuf::int32 pvp_mark() const;
  inline void set_pvp_mark(::google::protobuf::int32 value);
  
  // optional int32 level = 8;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 8;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // repeated .message.BattleMatchingResponse.UserMapData userMapDataList = 9;
  inline int usermapdatalist_size() const;
  inline void clear_usermapdatalist();
  static const int kUserMapDataListFieldNumber = 9;
  inline const ::message::BattleMatchingResponse_UserMapData& usermapdatalist(int index) const;
  inline ::message::BattleMatchingResponse_UserMapData* mutable_usermapdatalist(int index);
  inline ::message::BattleMatchingResponse_UserMapData* add_usermapdatalist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData >&
      usermapdatalist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData >*
      mutable_usermapdatalist();
  
  // repeated .message.BattleMatchingResponse.AttackerSoldiersAndSpell soldiersAndSpellList = 10;
  inline int soldiersandspelllist_size() const;
  inline void clear_soldiersandspelllist();
  static const int kSoldiersAndSpellListFieldNumber = 10;
  inline const ::message::BattleMatchingResponse_AttackerSoldiersAndSpell& soldiersandspelllist(int index) const;
  inline ::message::BattleMatchingResponse_AttackerSoldiersAndSpell* mutable_soldiersandspelllist(int index);
  inline ::message::BattleMatchingResponse_AttackerSoldiersAndSpell* add_soldiersandspelllist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_AttackerSoldiersAndSpell >&
      soldiersandspelllist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_AttackerSoldiersAndSpell >*
      mutable_soldiersandspelllist();
  
  // optional int32 used_clans_character_count = 11;
  inline bool has_used_clans_character_count() const;
  inline void clear_used_clans_character_count();
  static const int kUsedClansCharacterCountFieldNumber = 11;
  inline ::google::protobuf::int32 used_clans_character_count() const;
  inline void set_used_clans_character_count(::google::protobuf::int32 value);
  
  // optional int32 lose_pvp_mark = 12;
  inline bool has_lose_pvp_mark() const;
  inline void clear_lose_pvp_mark();
  static const int kLosePvpMarkFieldNumber = 12;
  inline ::google::protobuf::int32 lose_pvp_mark() const;
  inline void set_lose_pvp_mark(::google::protobuf::int32 value);
  
  // repeated .message.BattleMatchingResponse.BuildDestoryStatus BuildDistoryStatusList = 13;
  inline int builddistorystatuslist_size() const;
  inline void clear_builddistorystatuslist();
  static const int kBuildDistoryStatusListFieldNumber = 13;
  inline const ::message::BattleMatchingResponse_BuildDestoryStatus& builddistorystatuslist(int index) const;
  inline ::message::BattleMatchingResponse_BuildDestoryStatus* mutable_builddistorystatuslist(int index);
  inline ::message::BattleMatchingResponse_BuildDestoryStatus* add_builddistorystatuslist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_BuildDestoryStatus >&
      builddistorystatuslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_BuildDestoryStatus >*
      mutable_builddistorystatuslist();
  
  // @@protoc_insertion_point(class_scope:message.BattleMatchingResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_defencer_mailaddress();
  inline void clear_has_defencer_mailaddress();
  inline void set_has_nick_name();
  inline void clear_has_nick_name();
  inline void set_has_golden_count();
  inline void clear_has_golden_count();
  inline void set_has_elixir_count();
  inline void clear_has_elixir_count();
  inline void set_has_pvp_mark();
  inline void clear_has_pvp_mark();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_used_clans_character_count();
  inline void clear_has_used_clans_character_count();
  inline void set_has_lose_pvp_mark();
  inline void clear_has_lose_pvp_mark();
  
  ::std::string* info_;
  ::std::string* defencer_mailaddress_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 golden_count_;
  ::std::string* nick_name_;
  ::google::protobuf::int32 elixir_count_;
  ::google::protobuf::int32 pvp_mark_;
  ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData > usermapdatalist_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 used_clans_character_count_;
  ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_AttackerSoldiersAndSpell > soldiersandspelllist_;
  ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_BuildDestoryStatus > builddistorystatuslist_;
  ::google::protobuf::int32 lose_pvp_mark_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_BattleMatching_2eproto();
  friend void protobuf_AssignDesc_BattleMatching_2eproto();
  friend void protobuf_ShutdownFile_BattleMatching_2eproto();
  
  void InitAsDefaultInstance();
  static BattleMatchingResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// BattleMatchingRequest

// required string mailAddress = 1;
inline bool BattleMatchingRequest::has_mailaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleMatchingRequest::set_has_mailaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleMatchingRequest::clear_has_mailaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleMatchingRequest::clear_mailaddress() {
  if (mailaddress_ != &::google::protobuf::internal::kEmptyString) {
    mailaddress_->clear();
  }
  clear_has_mailaddress();
}
inline const ::std::string& BattleMatchingRequest::mailaddress() const {
  return *mailaddress_;
}
inline void BattleMatchingRequest::set_mailaddress(const ::std::string& value) {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  mailaddress_->assign(value);
}
inline void BattleMatchingRequest::set_mailaddress(const char* value) {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  mailaddress_->assign(value);
}
inline void BattleMatchingRequest::set_mailaddress(const char* value, size_t size) {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  mailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleMatchingRequest::mutable_mailaddress() {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  return mailaddress_;
}
inline ::std::string* BattleMatchingRequest::release_mailaddress() {
  clear_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailaddress_;
    mailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string previousMailAddress = 2;
inline bool BattleMatchingRequest::has_previousmailaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleMatchingRequest::set_has_previousmailaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleMatchingRequest::clear_has_previousmailaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleMatchingRequest::clear_previousmailaddress() {
  if (previousmailaddress_ != &::google::protobuf::internal::kEmptyString) {
    previousmailaddress_->clear();
  }
  clear_has_previousmailaddress();
}
inline const ::std::string& BattleMatchingRequest::previousmailaddress() const {
  return *previousmailaddress_;
}
inline void BattleMatchingRequest::set_previousmailaddress(const ::std::string& value) {
  set_has_previousmailaddress();
  if (previousmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    previousmailaddress_ = new ::std::string;
  }
  previousmailaddress_->assign(value);
}
inline void BattleMatchingRequest::set_previousmailaddress(const char* value) {
  set_has_previousmailaddress();
  if (previousmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    previousmailaddress_ = new ::std::string;
  }
  previousmailaddress_->assign(value);
}
inline void BattleMatchingRequest::set_previousmailaddress(const char* value, size_t size) {
  set_has_previousmailaddress();
  if (previousmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    previousmailaddress_ = new ::std::string;
  }
  previousmailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleMatchingRequest::mutable_previousmailaddress() {
  set_has_previousmailaddress();
  if (previousmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    previousmailaddress_ = new ::std::string;
  }
  return previousmailaddress_;
}
inline ::std::string* BattleMatchingRequest::release_previousmailaddress() {
  clear_has_previousmailaddress();
  if (previousmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = previousmailaddress_;
    previousmailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string str_md5 = 3;
inline bool BattleMatchingRequest::has_str_md5() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleMatchingRequest::set_has_str_md5() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleMatchingRequest::clear_has_str_md5() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleMatchingRequest::clear_str_md5() {
  if (str_md5_ != &::google::protobuf::internal::kEmptyString) {
    str_md5_->clear();
  }
  clear_has_str_md5();
}
inline const ::std::string& BattleMatchingRequest::str_md5() const {
  return *str_md5_;
}
inline void BattleMatchingRequest::set_str_md5(const ::std::string& value) {
  set_has_str_md5();
  if (str_md5_ == &::google::protobuf::internal::kEmptyString) {
    str_md5_ = new ::std::string;
  }
  str_md5_->assign(value);
}
inline void BattleMatchingRequest::set_str_md5(const char* value) {
  set_has_str_md5();
  if (str_md5_ == &::google::protobuf::internal::kEmptyString) {
    str_md5_ = new ::std::string;
  }
  str_md5_->assign(value);
}
inline void BattleMatchingRequest::set_str_md5(const char* value, size_t size) {
  set_has_str_md5();
  if (str_md5_ == &::google::protobuf::internal::kEmptyString) {
    str_md5_ = new ::std::string;
  }
  str_md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleMatchingRequest::mutable_str_md5() {
  set_has_str_md5();
  if (str_md5_ == &::google::protobuf::internal::kEmptyString) {
    str_md5_ = new ::std::string;
  }
  return str_md5_;
}
inline ::std::string* BattleMatchingRequest::release_str_md5() {
  clear_has_str_md5();
  if (str_md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_md5_;
    str_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 battle_status = 4;
inline bool BattleMatchingRequest::has_battle_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleMatchingRequest::set_has_battle_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleMatchingRequest::clear_has_battle_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleMatchingRequest::clear_battle_status() {
  battle_status_ = 0;
  clear_has_battle_status();
}
inline ::google::protobuf::int32 BattleMatchingRequest::battle_status() const {
  return battle_status_;
}
inline void BattleMatchingRequest::set_battle_status(::google::protobuf::int32 value) {
  set_has_battle_status();
  battle_status_ = value;
}

// -------------------------------------------------------------------

// BattleMatchingResponse_UserMapData_Clans

// optional int32 character_id = 1;
inline bool BattleMatchingResponse_UserMapData_Clans::has_character_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleMatchingResponse_UserMapData_Clans::set_has_character_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleMatchingResponse_UserMapData_Clans::clear_has_character_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleMatchingResponse_UserMapData_Clans::clear_character_id() {
  character_id_ = 0;
  clear_has_character_id();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData_Clans::character_id() const {
  return character_id_;
}
inline void BattleMatchingResponse_UserMapData_Clans::set_character_id(::google::protobuf::int32 value) {
  set_has_character_id();
  character_id_ = value;
}

// optional int32 character_level = 2;
inline bool BattleMatchingResponse_UserMapData_Clans::has_character_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleMatchingResponse_UserMapData_Clans::set_has_character_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleMatchingResponse_UserMapData_Clans::clear_has_character_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleMatchingResponse_UserMapData_Clans::clear_character_level() {
  character_level_ = 0;
  clear_has_character_level();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData_Clans::character_level() const {
  return character_level_;
}
inline void BattleMatchingResponse_UserMapData_Clans::set_character_level(::google::protobuf::int32 value) {
  set_has_character_level();
  character_level_ = value;
}

// optional int32 finished_produce_count = 3;
inline bool BattleMatchingResponse_UserMapData_Clans::has_finished_produce_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleMatchingResponse_UserMapData_Clans::set_has_finished_produce_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleMatchingResponse_UserMapData_Clans::clear_has_finished_produce_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleMatchingResponse_UserMapData_Clans::clear_finished_produce_count() {
  finished_produce_count_ = 0;
  clear_has_finished_produce_count();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData_Clans::finished_produce_count() const {
  return finished_produce_count_;
}
inline void BattleMatchingResponse_UserMapData_Clans::set_finished_produce_count(::google::protobuf::int32 value) {
  set_has_finished_produce_count();
  finished_produce_count_ = value;
}

// -------------------------------------------------------------------

// BattleMatchingResponse_UserMapData

// optional int32 map_index_x = 1;
inline bool BattleMatchingResponse_UserMapData::has_map_index_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_map_index_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_map_index_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleMatchingResponse_UserMapData::clear_map_index_x() {
  map_index_x_ = 0;
  clear_has_map_index_x();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::map_index_x() const {
  return map_index_x_;
}
inline void BattleMatchingResponse_UserMapData::set_map_index_x(::google::protobuf::int32 value) {
  set_has_map_index_x();
  map_index_x_ = value;
}

// optional int32 uniqueness_build_id = 2;
inline bool BattleMatchingResponse_UserMapData::has_uniqueness_build_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_uniqueness_build_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_uniqueness_build_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleMatchingResponse_UserMapData::clear_uniqueness_build_id() {
  uniqueness_build_id_ = 0;
  clear_has_uniqueness_build_id();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::uniqueness_build_id() const {
  return uniqueness_build_id_;
}
inline void BattleMatchingResponse_UserMapData::set_uniqueness_build_id(::google::protobuf::int32 value) {
  set_has_uniqueness_build_id();
  uniqueness_build_id_ = value;
}

// optional int32 status = 3;
inline bool BattleMatchingResponse_UserMapData::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleMatchingResponse_UserMapData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::status() const {
  return status_;
}
inline void BattleMatchingResponse_UserMapData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 building_id = 4;
inline bool BattleMatchingResponse_UserMapData::has_building_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_building_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_building_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleMatchingResponse_UserMapData::clear_building_id() {
  building_id_ = 0;
  clear_has_building_id();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::building_id() const {
  return building_id_;
}
inline void BattleMatchingResponse_UserMapData::set_building_id(::google::protobuf::int32 value) {
  set_has_building_id();
  building_id_ = value;
}

// optional int32 Building_level = 5;
inline bool BattleMatchingResponse_UserMapData::has_building_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_building_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_building_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleMatchingResponse_UserMapData::clear_building_level() {
  building_level_ = 0;
  clear_has_building_level();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::building_level() const {
  return building_level_;
}
inline void BattleMatchingResponse_UserMapData::set_building_level(::google::protobuf::int32 value) {
  set_has_building_level();
  building_level_ = value;
}

// optional int32 map_index_y = 6;
inline bool BattleMatchingResponse_UserMapData::has_map_index_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_map_index_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_map_index_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleMatchingResponse_UserMapData::clear_map_index_y() {
  map_index_y_ = 0;
  clear_has_map_index_y();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::map_index_y() const {
  return map_index_y_;
}
inline void BattleMatchingResponse_UserMapData::set_map_index_y(::google::protobuf::int32 value) {
  set_has_map_index_y();
  map_index_y_ = value;
}

// repeated .message.BattleMatchingResponse.UserMapData.Clans clansList = 7;
inline int BattleMatchingResponse_UserMapData::clanslist_size() const {
  return clanslist_.size();
}
inline void BattleMatchingResponse_UserMapData::clear_clanslist() {
  clanslist_.Clear();
}
inline const ::message::BattleMatchingResponse_UserMapData_Clans& BattleMatchingResponse_UserMapData::clanslist(int index) const {
  return clanslist_.Get(index);
}
inline ::message::BattleMatchingResponse_UserMapData_Clans* BattleMatchingResponse_UserMapData::mutable_clanslist(int index) {
  return clanslist_.Mutable(index);
}
inline ::message::BattleMatchingResponse_UserMapData_Clans* BattleMatchingResponse_UserMapData::add_clanslist() {
  return clanslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData_Clans >&
BattleMatchingResponse_UserMapData::clanslist() const {
  return clanslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData_Clans >*
BattleMatchingResponse_UserMapData::mutable_clanslist() {
  return &clanslist_;
}

// optional int32 collect_count = 8;
inline bool BattleMatchingResponse_UserMapData::has_collect_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_collect_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_collect_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleMatchingResponse_UserMapData::clear_collect_count() {
  collect_count_ = 0;
  clear_has_collect_count();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::collect_count() const {
  return collect_count_;
}
inline void BattleMatchingResponse_UserMapData::set_collect_count(::google::protobuf::int32 value) {
  set_has_collect_count();
  collect_count_ = value;
}

// optional int32 second_elixir_count = 9;
inline bool BattleMatchingResponse_UserMapData::has_second_elixir_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_second_elixir_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_second_elixir_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleMatchingResponse_UserMapData::clear_second_elixir_count() {
  second_elixir_count_ = 0;
  clear_has_second_elixir_count();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::second_elixir_count() const {
  return second_elixir_count_;
}
inline void BattleMatchingResponse_UserMapData::set_second_elixir_count(::google::protobuf::int32 value) {
  set_has_second_elixir_count();
  second_elixir_count_ = value;
}

// optional int32 building_status = 10;
inline bool BattleMatchingResponse_UserMapData::has_building_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleMatchingResponse_UserMapData::set_has_building_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleMatchingResponse_UserMapData::clear_has_building_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleMatchingResponse_UserMapData::clear_building_status() {
  building_status_ = 0;
  clear_has_building_status();
}
inline ::google::protobuf::int32 BattleMatchingResponse_UserMapData::building_status() const {
  return building_status_;
}
inline void BattleMatchingResponse_UserMapData::set_building_status(::google::protobuf::int32 value) {
  set_has_building_status();
  building_status_ = value;
}

// -------------------------------------------------------------------

// BattleMatchingResponse_AttackerSoldiersAndSpell

// optional int32 characterIdOrSpellId = 1;
inline bool BattleMatchingResponse_AttackerSoldiersAndSpell::has_characteridorspellid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_has_characteridorspellid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_has_characteridorspellid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_characteridorspellid() {
  characteridorspellid_ = 0;
  clear_has_characteridorspellid();
}
inline ::google::protobuf::int32 BattleMatchingResponse_AttackerSoldiersAndSpell::characteridorspellid() const {
  return characteridorspellid_;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_characteridorspellid(::google::protobuf::int32 value) {
  set_has_characteridorspellid();
  characteridorspellid_ = value;
}

// optional int32 characterOrSpellLevel = 2;
inline bool BattleMatchingResponse_AttackerSoldiersAndSpell::has_characterorspelllevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_has_characterorspelllevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_has_characterorspelllevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_characterorspelllevel() {
  characterorspelllevel_ = 0;
  clear_has_characterorspelllevel();
}
inline ::google::protobuf::int32 BattleMatchingResponse_AttackerSoldiersAndSpell::characterorspelllevel() const {
  return characterorspelllevel_;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_characterorspelllevel(::google::protobuf::int32 value) {
  set_has_characterorspelllevel();
  characterorspelllevel_ = value;
}

// optional int32 count = 3;
inline bool BattleMatchingResponse_AttackerSoldiersAndSpell::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 BattleMatchingResponse_AttackerSoldiersAndSpell::count() const {
  return count_;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 used_type = 4;
inline bool BattleMatchingResponse_AttackerSoldiersAndSpell::has_used_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_has_used_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_has_used_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::clear_used_type() {
  used_type_ = 0;
  clear_has_used_type();
}
inline ::google::protobuf::int32 BattleMatchingResponse_AttackerSoldiersAndSpell::used_type() const {
  return used_type_;
}
inline void BattleMatchingResponse_AttackerSoldiersAndSpell::set_used_type(::google::protobuf::int32 value) {
  set_has_used_type();
  used_type_ = value;
}

// -------------------------------------------------------------------

// BattleMatchingResponse_BuildDestoryStatus

// optional int32 building_id = 1;
inline bool BattleMatchingResponse_BuildDestoryStatus::has_building_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_has_building_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_has_building_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_building_id() {
  building_id_ = 0;
  clear_has_building_id();
}
inline ::google::protobuf::int32 BattleMatchingResponse_BuildDestoryStatus::building_id() const {
  return building_id_;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_building_id(::google::protobuf::int32 value) {
  set_has_building_id();
  building_id_ = value;
}

// optional int32 uuid = 2;
inline bool BattleMatchingResponse_BuildDestoryStatus::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_uuid() {
  uuid_ = 0;
  clear_has_uuid();
}
inline ::google::protobuf::int32 BattleMatchingResponse_BuildDestoryStatus::uuid() const {
  return uuid_;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_uuid(::google::protobuf::int32 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional int32 map_index_x = 3;
inline bool BattleMatchingResponse_BuildDestoryStatus::has_map_index_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_has_map_index_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_has_map_index_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_map_index_x() {
  map_index_x_ = 0;
  clear_has_map_index_x();
}
inline ::google::protobuf::int32 BattleMatchingResponse_BuildDestoryStatus::map_index_x() const {
  return map_index_x_;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_map_index_x(::google::protobuf::int32 value) {
  set_has_map_index_x();
  map_index_x_ = value;
}

// optional int32 map_index_y = 4;
inline bool BattleMatchingResponse_BuildDestoryStatus::has_map_index_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_has_map_index_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_has_map_index_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleMatchingResponse_BuildDestoryStatus::clear_map_index_y() {
  map_index_y_ = 0;
  clear_has_map_index_y();
}
inline ::google::protobuf::int32 BattleMatchingResponse_BuildDestoryStatus::map_index_y() const {
  return map_index_y_;
}
inline void BattleMatchingResponse_BuildDestoryStatus::set_map_index_y(::google::protobuf::int32 value) {
  set_has_map_index_y();
  map_index_y_ = value;
}

// -------------------------------------------------------------------

// BattleMatchingResponse

// optional sint32 result = 1 [default = 0];
inline bool BattleMatchingResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleMatchingResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleMatchingResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleMatchingResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 BattleMatchingResponse::result() const {
  return result_;
}
inline void BattleMatchingResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string info = 2;
inline bool BattleMatchingResponse::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleMatchingResponse::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleMatchingResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleMatchingResponse::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& BattleMatchingResponse::info() const {
  return *info_;
}
inline void BattleMatchingResponse::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void BattleMatchingResponse::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void BattleMatchingResponse::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleMatchingResponse::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* BattleMatchingResponse::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string defencer_mailaddress = 3;
inline bool BattleMatchingResponse::has_defencer_mailaddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleMatchingResponse::set_has_defencer_mailaddress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleMatchingResponse::clear_has_defencer_mailaddress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleMatchingResponse::clear_defencer_mailaddress() {
  if (defencer_mailaddress_ != &::google::protobuf::internal::kEmptyString) {
    defencer_mailaddress_->clear();
  }
  clear_has_defencer_mailaddress();
}
inline const ::std::string& BattleMatchingResponse::defencer_mailaddress() const {
  return *defencer_mailaddress_;
}
inline void BattleMatchingResponse::set_defencer_mailaddress(const ::std::string& value) {
  set_has_defencer_mailaddress();
  if (defencer_mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    defencer_mailaddress_ = new ::std::string;
  }
  defencer_mailaddress_->assign(value);
}
inline void BattleMatchingResponse::set_defencer_mailaddress(const char* value) {
  set_has_defencer_mailaddress();
  if (defencer_mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    defencer_mailaddress_ = new ::std::string;
  }
  defencer_mailaddress_->assign(value);
}
inline void BattleMatchingResponse::set_defencer_mailaddress(const char* value, size_t size) {
  set_has_defencer_mailaddress();
  if (defencer_mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    defencer_mailaddress_ = new ::std::string;
  }
  defencer_mailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleMatchingResponse::mutable_defencer_mailaddress() {
  set_has_defencer_mailaddress();
  if (defencer_mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    defencer_mailaddress_ = new ::std::string;
  }
  return defencer_mailaddress_;
}
inline ::std::string* BattleMatchingResponse::release_defencer_mailaddress() {
  clear_has_defencer_mailaddress();
  if (defencer_mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defencer_mailaddress_;
    defencer_mailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nick_name = 4;
inline bool BattleMatchingResponse::has_nick_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleMatchingResponse::set_has_nick_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleMatchingResponse::clear_has_nick_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleMatchingResponse::clear_nick_name() {
  if (nick_name_ != &::google::protobuf::internal::kEmptyString) {
    nick_name_->clear();
  }
  clear_has_nick_name();
}
inline const ::std::string& BattleMatchingResponse::nick_name() const {
  return *nick_name_;
}
inline void BattleMatchingResponse::set_nick_name(const ::std::string& value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void BattleMatchingResponse::set_nick_name(const char* value) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(value);
}
inline void BattleMatchingResponse::set_nick_name(const char* value, size_t size) {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  nick_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleMatchingResponse::mutable_nick_name() {
  set_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    nick_name_ = new ::std::string;
  }
  return nick_name_;
}
inline ::std::string* BattleMatchingResponse::release_nick_name() {
  clear_has_nick_name();
  if (nick_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_name_;
    nick_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 golden_count = 5;
inline bool BattleMatchingResponse::has_golden_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleMatchingResponse::set_has_golden_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleMatchingResponse::clear_has_golden_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleMatchingResponse::clear_golden_count() {
  golden_count_ = 0;
  clear_has_golden_count();
}
inline ::google::protobuf::int32 BattleMatchingResponse::golden_count() const {
  return golden_count_;
}
inline void BattleMatchingResponse::set_golden_count(::google::protobuf::int32 value) {
  set_has_golden_count();
  golden_count_ = value;
}

// optional int32 elixir_count = 6;
inline bool BattleMatchingResponse::has_elixir_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleMatchingResponse::set_has_elixir_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleMatchingResponse::clear_has_elixir_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleMatchingResponse::clear_elixir_count() {
  elixir_count_ = 0;
  clear_has_elixir_count();
}
inline ::google::protobuf::int32 BattleMatchingResponse::elixir_count() const {
  return elixir_count_;
}
inline void BattleMatchingResponse::set_elixir_count(::google::protobuf::int32 value) {
  set_has_elixir_count();
  elixir_count_ = value;
}

// optional int32 pvp_mark = 7;
inline bool BattleMatchingResponse::has_pvp_mark() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleMatchingResponse::set_has_pvp_mark() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleMatchingResponse::clear_has_pvp_mark() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleMatchingResponse::clear_pvp_mark() {
  pvp_mark_ = 0;
  clear_has_pvp_mark();
}
inline ::google::protobuf::int32 BattleMatchingResponse::pvp_mark() const {
  return pvp_mark_;
}
inline void BattleMatchingResponse::set_pvp_mark(::google::protobuf::int32 value) {
  set_has_pvp_mark();
  pvp_mark_ = value;
}

// optional int32 level = 8;
inline bool BattleMatchingResponse::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleMatchingResponse::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleMatchingResponse::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleMatchingResponse::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BattleMatchingResponse::level() const {
  return level_;
}
inline void BattleMatchingResponse::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// repeated .message.BattleMatchingResponse.UserMapData userMapDataList = 9;
inline int BattleMatchingResponse::usermapdatalist_size() const {
  return usermapdatalist_.size();
}
inline void BattleMatchingResponse::clear_usermapdatalist() {
  usermapdatalist_.Clear();
}
inline const ::message::BattleMatchingResponse_UserMapData& BattleMatchingResponse::usermapdatalist(int index) const {
  return usermapdatalist_.Get(index);
}
inline ::message::BattleMatchingResponse_UserMapData* BattleMatchingResponse::mutable_usermapdatalist(int index) {
  return usermapdatalist_.Mutable(index);
}
inline ::message::BattleMatchingResponse_UserMapData* BattleMatchingResponse::add_usermapdatalist() {
  return usermapdatalist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData >&
BattleMatchingResponse::usermapdatalist() const {
  return usermapdatalist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_UserMapData >*
BattleMatchingResponse::mutable_usermapdatalist() {
  return &usermapdatalist_;
}

// repeated .message.BattleMatchingResponse.AttackerSoldiersAndSpell soldiersAndSpellList = 10;
inline int BattleMatchingResponse::soldiersandspelllist_size() const {
  return soldiersandspelllist_.size();
}
inline void BattleMatchingResponse::clear_soldiersandspelllist() {
  soldiersandspelllist_.Clear();
}
inline const ::message::BattleMatchingResponse_AttackerSoldiersAndSpell& BattleMatchingResponse::soldiersandspelllist(int index) const {
  return soldiersandspelllist_.Get(index);
}
inline ::message::BattleMatchingResponse_AttackerSoldiersAndSpell* BattleMatchingResponse::mutable_soldiersandspelllist(int index) {
  return soldiersandspelllist_.Mutable(index);
}
inline ::message::BattleMatchingResponse_AttackerSoldiersAndSpell* BattleMatchingResponse::add_soldiersandspelllist() {
  return soldiersandspelllist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_AttackerSoldiersAndSpell >&
BattleMatchingResponse::soldiersandspelllist() const {
  return soldiersandspelllist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_AttackerSoldiersAndSpell >*
BattleMatchingResponse::mutable_soldiersandspelllist() {
  return &soldiersandspelllist_;
}

// optional int32 used_clans_character_count = 11;
inline bool BattleMatchingResponse::has_used_clans_character_count() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleMatchingResponse::set_has_used_clans_character_count() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleMatchingResponse::clear_has_used_clans_character_count() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleMatchingResponse::clear_used_clans_character_count() {
  used_clans_character_count_ = 0;
  clear_has_used_clans_character_count();
}
inline ::google::protobuf::int32 BattleMatchingResponse::used_clans_character_count() const {
  return used_clans_character_count_;
}
inline void BattleMatchingResponse::set_used_clans_character_count(::google::protobuf::int32 value) {
  set_has_used_clans_character_count();
  used_clans_character_count_ = value;
}

// optional int32 lose_pvp_mark = 12;
inline bool BattleMatchingResponse::has_lose_pvp_mark() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BattleMatchingResponse::set_has_lose_pvp_mark() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BattleMatchingResponse::clear_has_lose_pvp_mark() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BattleMatchingResponse::clear_lose_pvp_mark() {
  lose_pvp_mark_ = 0;
  clear_has_lose_pvp_mark();
}
inline ::google::protobuf::int32 BattleMatchingResponse::lose_pvp_mark() const {
  return lose_pvp_mark_;
}
inline void BattleMatchingResponse::set_lose_pvp_mark(::google::protobuf::int32 value) {
  set_has_lose_pvp_mark();
  lose_pvp_mark_ = value;
}

// repeated .message.BattleMatchingResponse.BuildDestoryStatus BuildDistoryStatusList = 13;
inline int BattleMatchingResponse::builddistorystatuslist_size() const {
  return builddistorystatuslist_.size();
}
inline void BattleMatchingResponse::clear_builddistorystatuslist() {
  builddistorystatuslist_.Clear();
}
inline const ::message::BattleMatchingResponse_BuildDestoryStatus& BattleMatchingResponse::builddistorystatuslist(int index) const {
  return builddistorystatuslist_.Get(index);
}
inline ::message::BattleMatchingResponse_BuildDestoryStatus* BattleMatchingResponse::mutable_builddistorystatuslist(int index) {
  return builddistorystatuslist_.Mutable(index);
}
inline ::message::BattleMatchingResponse_BuildDestoryStatus* BattleMatchingResponse::add_builddistorystatuslist() {
  return builddistorystatuslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_BuildDestoryStatus >&
BattleMatchingResponse::builddistorystatuslist() const {
  return builddistorystatuslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::BattleMatchingResponse_BuildDestoryStatus >*
BattleMatchingResponse::mutable_builddistorystatuslist() {
  return &builddistorystatuslist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BattleMatching_2eproto__INCLUDED
