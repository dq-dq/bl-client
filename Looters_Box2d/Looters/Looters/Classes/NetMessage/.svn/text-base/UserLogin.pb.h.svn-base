// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserLogin.proto

#ifndef PROTOBUF_UserLogin_2eproto__INCLUDED
#define PROTOBUF_UserLogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_UserLogin_2eproto();
void protobuf_AssignDesc_UserLogin_2eproto();
void protobuf_ShutdownFile_UserLogin_2eproto();

class UserLoginRequest;
class UserLoginResponse;
class UserLoginResponse_AreaData;

// ===================================================================

class UserLoginRequest : public ::google::protobuf::MessageLite {
 public:
  UserLoginRequest();
  virtual ~UserLoginRequest();
  
  UserLoginRequest(const UserLoginRequest& from);
  
  inline UserLoginRequest& operator=(const UserLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UserLoginRequest& default_instance();
  
  void Swap(UserLoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  UserLoginRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserLoginRequest& from);
  void MergeFrom(const UserLoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mailAddress = 1;
  inline bool has_mailaddress() const;
  inline void clear_mailaddress();
  static const int kMailAddressFieldNumber = 1;
  inline const ::std::string& mailaddress() const;
  inline void set_mailaddress(const ::std::string& value);
  inline void set_mailaddress(const char* value);
  inline void set_mailaddress(const char* value, size_t size);
  inline ::std::string* mutable_mailaddress();
  inline ::std::string* release_mailaddress();
  
  // required string language = 2;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 2;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  
  // required string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional string machineNum = 4;
  inline bool has_machinenum() const;
  inline void clear_machinenum();
  static const int kMachineNumFieldNumber = 4;
  inline const ::std::string& machinenum() const;
  inline void set_machinenum(const ::std::string& value);
  inline void set_machinenum(const char* value);
  inline void set_machinenum(const char* value, size_t size);
  inline ::std::string* mutable_machinenum();
  inline ::std::string* release_machinenum();
  
  // optional int32 instance_id = 5;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 5;
  inline ::google::protobuf::int32 instance_id() const;
  inline void set_instance_id(::google::protobuf::int32 value);
  
  // optional int32 area_id = 6;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 6;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);
  
  // optional string loginId = 7;
  inline bool has_loginid() const;
  inline void clear_loginid();
  static const int kLoginIdFieldNumber = 7;
  inline const ::std::string& loginid() const;
  inline void set_loginid(const ::std::string& value);
  inline void set_loginid(const char* value);
  inline void set_loginid(const char* value, size_t size);
  inline ::std::string* mutable_loginid();
  inline ::std::string* release_loginid();
  
  // optional int32 third_party_type = 8 [default = 0];
  inline bool has_third_party_type() const;
  inline void clear_third_party_type();
  static const int kThirdPartyTypeFieldNumber = 8;
  inline ::google::protobuf::int32 third_party_type() const;
  inline void set_third_party_type(::google::protobuf::int32 value);
  
  // optional int32 login_type = 9 [default = 0];
  inline bool has_login_type() const;
  inline void clear_login_type();
  static const int kLoginTypeFieldNumber = 9;
  inline ::google::protobuf::int32 login_type() const;
  inline void set_login_type(::google::protobuf::int32 value);
  
  // optional string password = 10;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 10;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:message.UserLoginRequest)
 private:
  inline void set_has_mailaddress();
  inline void clear_has_mailaddress();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_machinenum();
  inline void clear_has_machinenum();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_loginid();
  inline void clear_has_loginid();
  inline void set_has_third_party_type();
  inline void clear_has_third_party_type();
  inline void set_has_login_type();
  inline void clear_has_login_type();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::std::string* mailaddress_;
  ::std::string* language_;
  ::std::string* version_;
  ::std::string* machinenum_;
  ::google::protobuf::int32 instance_id_;
  ::google::protobuf::int32 area_id_;
  ::std::string* loginid_;
  ::google::protobuf::int32 third_party_type_;
  ::google::protobuf::int32 login_type_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserLogin_2eproto();
  friend void protobuf_AssignDesc_UserLogin_2eproto();
  friend void protobuf_ShutdownFile_UserLogin_2eproto();
  
  void InitAsDefaultInstance();
  static UserLoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginResponse_AreaData : public ::google::protobuf::MessageLite {
 public:
  UserLoginResponse_AreaData();
  virtual ~UserLoginResponse_AreaData();
  
  UserLoginResponse_AreaData(const UserLoginResponse_AreaData& from);
  
  inline UserLoginResponse_AreaData& operator=(const UserLoginResponse_AreaData& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UserLoginResponse_AreaData& default_instance();
  
  void Swap(UserLoginResponse_AreaData* other);
  
  // implements Message ----------------------------------------------
  
  UserLoginResponse_AreaData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserLoginResponse_AreaData& from);
  void MergeFrom(const UserLoginResponse_AreaData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 area_id = 1;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 1;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);
  
  // optional string area_name = 2;
  inline bool has_area_name() const;
  inline void clear_area_name();
  static const int kAreaNameFieldNumber = 2;
  inline const ::std::string& area_name() const;
  inline void set_area_name(const ::std::string& value);
  inline void set_area_name(const char* value);
  inline void set_area_name(const char* value, size_t size);
  inline ::std::string* mutable_area_name();
  inline ::std::string* release_area_name();
  
  // @@protoc_insertion_point(class_scope:message.UserLoginResponse.AreaData)
 private:
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_area_name();
  inline void clear_has_area_name();
  
  ::std::string* area_name_;
  ::google::protobuf::int32 area_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserLogin_2eproto();
  friend void protobuf_AssignDesc_UserLogin_2eproto();
  friend void protobuf_ShutdownFile_UserLogin_2eproto();
  
  void InitAsDefaultInstance();
  static UserLoginResponse_AreaData* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginResponse : public ::google::protobuf::MessageLite {
 public:
  UserLoginResponse();
  virtual ~UserLoginResponse();
  
  UserLoginResponse(const UserLoginResponse& from);
  
  inline UserLoginResponse& operator=(const UserLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const UserLoginResponse& default_instance();
  
  void Swap(UserLoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  UserLoginResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserLoginResponse& from);
  void MergeFrom(const UserLoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  typedef UserLoginResponse_AreaData AreaData;
  
  // accessors -------------------------------------------------------
  
  // optional sint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // optional string gameServerAddress = 3;
  inline bool has_gameserveraddress() const;
  inline void clear_gameserveraddress();
  static const int kGameServerAddressFieldNumber = 3;
  inline const ::std::string& gameserveraddress() const;
  inline void set_gameserveraddress(const ::std::string& value);
  inline void set_gameserveraddress(const char* value);
  inline void set_gameserveraddress(const char* value, size_t size);
  inline ::std::string* mutable_gameserveraddress();
  inline ::std::string* release_gameserveraddress();
  
  // optional uint64 verifyCode = 4;
  inline bool has_verifycode() const;
  inline void clear_verifycode();
  static const int kVerifyCodeFieldNumber = 4;
  inline ::google::protobuf::uint64 verifycode() const;
  inline void set_verifycode(::google::protobuf::uint64 value);
  
  // optional string version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // optional int32 updateAble = 6;
  inline bool has_updateable() const;
  inline void clear_updateable();
  static const int kUpdateAbleFieldNumber = 6;
  inline ::google::protobuf::int32 updateable() const;
  inline void set_updateable(::google::protobuf::int32 value);
  
  // optional string fileServerAddress = 7;
  inline bool has_fileserveraddress() const;
  inline void clear_fileserveraddress();
  static const int kFileServerAddressFieldNumber = 7;
  inline const ::std::string& fileserveraddress() const;
  inline void set_fileserveraddress(const ::std::string& value);
  inline void set_fileserveraddress(const char* value);
  inline void set_fileserveraddress(const char* value, size_t size);
  inline ::std::string* mutable_fileserveraddress();
  inline ::std::string* release_fileserveraddress();
  
  // optional int32 instance_id = 8;
  inline bool has_instance_id() const;
  inline void clear_instance_id();
  static const int kInstanceIdFieldNumber = 8;
  inline ::google::protobuf::int32 instance_id() const;
  inline void set_instance_id(::google::protobuf::int32 value);
  
  // optional string tempMailAddress = 9;
  inline bool has_tempmailaddress() const;
  inline void clear_tempmailaddress();
  static const int kTempMailAddressFieldNumber = 9;
  inline const ::std::string& tempmailaddress() const;
  inline void set_tempmailaddress(const ::std::string& value);
  inline void set_tempmailaddress(const char* value);
  inline void set_tempmailaddress(const char* value, size_t size);
  inline ::std::string* mutable_tempmailaddress();
  inline ::std::string* release_tempmailaddress();
  
  // optional int32 area_id = 10;
  inline bool has_area_id() const;
  inline void clear_area_id();
  static const int kAreaIdFieldNumber = 10;
  inline ::google::protobuf::int32 area_id() const;
  inline void set_area_id(::google::protobuf::int32 value);
  
  // optional string bankServer = 11;
  inline bool has_bankserver() const;
  inline void clear_bankserver();
  static const int kBankServerFieldNumber = 11;
  inline const ::std::string& bankserver() const;
  inline void set_bankserver(const ::std::string& value);
  inline void set_bankserver(const char* value);
  inline void set_bankserver(const char* value, size_t size);
  inline ::std::string* mutable_bankserver();
  inline ::std::string* release_bankserver();
  
  // optional string area_name = 12;
  inline bool has_area_name() const;
  inline void clear_area_name();
  static const int kAreaNameFieldNumber = 12;
  inline const ::std::string& area_name() const;
  inline void set_area_name(const ::std::string& value);
  inline void set_area_name(const char* value);
  inline void set_area_name(const char* value, size_t size);
  inline ::std::string* mutable_area_name();
  inline ::std::string* release_area_name();
  
  // repeated .message.UserLoginResponse.AreaData areaDataList = 13;
  inline int areadatalist_size() const;
  inline void clear_areadatalist();
  static const int kAreaDataListFieldNumber = 13;
  inline const ::message::UserLoginResponse_AreaData& areadatalist(int index) const;
  inline ::message::UserLoginResponse_AreaData* mutable_areadatalist(int index);
  inline ::message::UserLoginResponse_AreaData* add_areadatalist();
  inline const ::google::protobuf::RepeatedPtrField< ::message::UserLoginResponse_AreaData >&
      areadatalist() const;
  inline ::google::protobuf::RepeatedPtrField< ::message::UserLoginResponse_AreaData >*
      mutable_areadatalist();
  
  // @@protoc_insertion_point(class_scope:message.UserLoginResponse)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_gameserveraddress();
  inline void clear_has_gameserveraddress();
  inline void set_has_verifycode();
  inline void clear_has_verifycode();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_updateable();
  inline void clear_has_updateable();
  inline void set_has_fileserveraddress();
  inline void clear_has_fileserveraddress();
  inline void set_has_instance_id();
  inline void clear_has_instance_id();
  inline void set_has_tempmailaddress();
  inline void clear_has_tempmailaddress();
  inline void set_has_area_id();
  inline void clear_has_area_id();
  inline void set_has_bankserver();
  inline void clear_has_bankserver();
  inline void set_has_area_name();
  inline void clear_has_area_name();
  
  ::std::string* info_;
  ::std::string* gameserveraddress_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 updateable_;
  ::google::protobuf::uint64 verifycode_;
  ::std::string* version_;
  ::std::string* fileserveraddress_;
  ::std::string* tempmailaddress_;
  ::google::protobuf::int32 instance_id_;
  ::google::protobuf::int32 area_id_;
  ::std::string* bankserver_;
  ::std::string* area_name_;
  ::google::protobuf::RepeatedPtrField< ::message::UserLoginResponse_AreaData > areadatalist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserLogin_2eproto();
  friend void protobuf_AssignDesc_UserLogin_2eproto();
  friend void protobuf_ShutdownFile_UserLogin_2eproto();
  
  void InitAsDefaultInstance();
  static UserLoginResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// UserLoginRequest

// required string mailAddress = 1;
inline bool UserLoginRequest::has_mailaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginRequest::set_has_mailaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginRequest::clear_has_mailaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginRequest::clear_mailaddress() {
  if (mailaddress_ != &::google::protobuf::internal::kEmptyString) {
    mailaddress_->clear();
  }
  clear_has_mailaddress();
}
inline const ::std::string& UserLoginRequest::mailaddress() const {
  return *mailaddress_;
}
inline void UserLoginRequest::set_mailaddress(const ::std::string& value) {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  mailaddress_->assign(value);
}
inline void UserLoginRequest::set_mailaddress(const char* value) {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  mailaddress_->assign(value);
}
inline void UserLoginRequest::set_mailaddress(const char* value, size_t size) {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  mailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRequest::mutable_mailaddress() {
  set_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    mailaddress_ = new ::std::string;
  }
  return mailaddress_;
}
inline ::std::string* UserLoginRequest::release_mailaddress() {
  clear_has_mailaddress();
  if (mailaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mailaddress_;
    mailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string language = 2;
inline bool UserLoginRequest::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginRequest::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginRequest::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& UserLoginRequest::language() const {
  return *language_;
}
inline void UserLoginRequest::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void UserLoginRequest::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void UserLoginRequest::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRequest::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* UserLoginRequest::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string version = 3;
inline bool UserLoginRequest::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginRequest::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLoginRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLoginRequest::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UserLoginRequest::version() const {
  return *version_;
}
inline void UserLoginRequest::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UserLoginRequest::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UserLoginRequest::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRequest::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UserLoginRequest::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string machineNum = 4;
inline bool UserLoginRequest::has_machinenum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginRequest::set_has_machinenum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLoginRequest::clear_has_machinenum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLoginRequest::clear_machinenum() {
  if (machinenum_ != &::google::protobuf::internal::kEmptyString) {
    machinenum_->clear();
  }
  clear_has_machinenum();
}
inline const ::std::string& UserLoginRequest::machinenum() const {
  return *machinenum_;
}
inline void UserLoginRequest::set_machinenum(const ::std::string& value) {
  set_has_machinenum();
  if (machinenum_ == &::google::protobuf::internal::kEmptyString) {
    machinenum_ = new ::std::string;
  }
  machinenum_->assign(value);
}
inline void UserLoginRequest::set_machinenum(const char* value) {
  set_has_machinenum();
  if (machinenum_ == &::google::protobuf::internal::kEmptyString) {
    machinenum_ = new ::std::string;
  }
  machinenum_->assign(value);
}
inline void UserLoginRequest::set_machinenum(const char* value, size_t size) {
  set_has_machinenum();
  if (machinenum_ == &::google::protobuf::internal::kEmptyString) {
    machinenum_ = new ::std::string;
  }
  machinenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRequest::mutable_machinenum() {
  set_has_machinenum();
  if (machinenum_ == &::google::protobuf::internal::kEmptyString) {
    machinenum_ = new ::std::string;
  }
  return machinenum_;
}
inline ::std::string* UserLoginRequest::release_machinenum() {
  clear_has_machinenum();
  if (machinenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machinenum_;
    machinenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 instance_id = 5;
inline bool UserLoginRequest::has_instance_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLoginRequest::set_has_instance_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLoginRequest::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLoginRequest::clear_instance_id() {
  instance_id_ = 0;
  clear_has_instance_id();
}
inline ::google::protobuf::int32 UserLoginRequest::instance_id() const {
  return instance_id_;
}
inline void UserLoginRequest::set_instance_id(::google::protobuf::int32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// optional int32 area_id = 6;
inline bool UserLoginRequest::has_area_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserLoginRequest::set_has_area_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserLoginRequest::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserLoginRequest::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 UserLoginRequest::area_id() const {
  return area_id_;
}
inline void UserLoginRequest::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional string loginId = 7;
inline bool UserLoginRequest::has_loginid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLoginRequest::set_has_loginid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserLoginRequest::clear_has_loginid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserLoginRequest::clear_loginid() {
  if (loginid_ != &::google::protobuf::internal::kEmptyString) {
    loginid_->clear();
  }
  clear_has_loginid();
}
inline const ::std::string& UserLoginRequest::loginid() const {
  return *loginid_;
}
inline void UserLoginRequest::set_loginid(const ::std::string& value) {
  set_has_loginid();
  if (loginid_ == &::google::protobuf::internal::kEmptyString) {
    loginid_ = new ::std::string;
  }
  loginid_->assign(value);
}
inline void UserLoginRequest::set_loginid(const char* value) {
  set_has_loginid();
  if (loginid_ == &::google::protobuf::internal::kEmptyString) {
    loginid_ = new ::std::string;
  }
  loginid_->assign(value);
}
inline void UserLoginRequest::set_loginid(const char* value, size_t size) {
  set_has_loginid();
  if (loginid_ == &::google::protobuf::internal::kEmptyString) {
    loginid_ = new ::std::string;
  }
  loginid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRequest::mutable_loginid() {
  set_has_loginid();
  if (loginid_ == &::google::protobuf::internal::kEmptyString) {
    loginid_ = new ::std::string;
  }
  return loginid_;
}
inline ::std::string* UserLoginRequest::release_loginid() {
  clear_has_loginid();
  if (loginid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loginid_;
    loginid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 third_party_type = 8 [default = 0];
inline bool UserLoginRequest::has_third_party_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLoginRequest::set_has_third_party_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserLoginRequest::clear_has_third_party_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserLoginRequest::clear_third_party_type() {
  third_party_type_ = 0;
  clear_has_third_party_type();
}
inline ::google::protobuf::int32 UserLoginRequest::third_party_type() const {
  return third_party_type_;
}
inline void UserLoginRequest::set_third_party_type(::google::protobuf::int32 value) {
  set_has_third_party_type();
  third_party_type_ = value;
}

// optional int32 login_type = 9 [default = 0];
inline bool UserLoginRequest::has_login_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserLoginRequest::set_has_login_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserLoginRequest::clear_has_login_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserLoginRequest::clear_login_type() {
  login_type_ = 0;
  clear_has_login_type();
}
inline ::google::protobuf::int32 UserLoginRequest::login_type() const {
  return login_type_;
}
inline void UserLoginRequest::set_login_type(::google::protobuf::int32 value) {
  set_has_login_type();
  login_type_ = value;
}

// optional string password = 10;
inline bool UserLoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserLoginRequest::set_has_password() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserLoginRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserLoginRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& UserLoginRequest::password() const {
  return *password_;
}
inline void UserLoginRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserLoginRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserLoginRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* UserLoginRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UserLoginResponse_AreaData

// optional int32 area_id = 1;
inline bool UserLoginResponse_AreaData::has_area_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginResponse_AreaData::set_has_area_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginResponse_AreaData::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginResponse_AreaData::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 UserLoginResponse_AreaData::area_id() const {
  return area_id_;
}
inline void UserLoginResponse_AreaData::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional string area_name = 2;
inline bool UserLoginResponse_AreaData::has_area_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginResponse_AreaData::set_has_area_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginResponse_AreaData::clear_has_area_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginResponse_AreaData::clear_area_name() {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    area_name_->clear();
  }
  clear_has_area_name();
}
inline const ::std::string& UserLoginResponse_AreaData::area_name() const {
  return *area_name_;
}
inline void UserLoginResponse_AreaData::set_area_name(const ::std::string& value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void UserLoginResponse_AreaData::set_area_name(const char* value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void UserLoginResponse_AreaData::set_area_name(const char* value, size_t size) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse_AreaData::mutable_area_name() {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  return area_name_;
}
inline ::std::string* UserLoginResponse_AreaData::release_area_name() {
  clear_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_name_;
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UserLoginResponse

// optional sint32 result = 1;
inline bool UserLoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 UserLoginResponse::result() const {
  return result_;
}
inline void UserLoginResponse::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string info = 2;
inline bool UserLoginResponse::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginResponse::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginResponse::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& UserLoginResponse::info() const {
  return *info_;
}
inline void UserLoginResponse::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void UserLoginResponse::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void UserLoginResponse::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* UserLoginResponse::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string gameServerAddress = 3;
inline bool UserLoginResponse::has_gameserveraddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginResponse::set_has_gameserveraddress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLoginResponse::clear_has_gameserveraddress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLoginResponse::clear_gameserveraddress() {
  if (gameserveraddress_ != &::google::protobuf::internal::kEmptyString) {
    gameserveraddress_->clear();
  }
  clear_has_gameserveraddress();
}
inline const ::std::string& UserLoginResponse::gameserveraddress() const {
  return *gameserveraddress_;
}
inline void UserLoginResponse::set_gameserveraddress(const ::std::string& value) {
  set_has_gameserveraddress();
  if (gameserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    gameserveraddress_ = new ::std::string;
  }
  gameserveraddress_->assign(value);
}
inline void UserLoginResponse::set_gameserveraddress(const char* value) {
  set_has_gameserveraddress();
  if (gameserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    gameserveraddress_ = new ::std::string;
  }
  gameserveraddress_->assign(value);
}
inline void UserLoginResponse::set_gameserveraddress(const char* value, size_t size) {
  set_has_gameserveraddress();
  if (gameserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    gameserveraddress_ = new ::std::string;
  }
  gameserveraddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_gameserveraddress() {
  set_has_gameserveraddress();
  if (gameserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    gameserveraddress_ = new ::std::string;
  }
  return gameserveraddress_;
}
inline ::std::string* UserLoginResponse::release_gameserveraddress() {
  clear_has_gameserveraddress();
  if (gameserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameserveraddress_;
    gameserveraddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 verifyCode = 4;
inline bool UserLoginResponse::has_verifycode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginResponse::set_has_verifycode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLoginResponse::clear_has_verifycode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLoginResponse::clear_verifycode() {
  verifycode_ = GOOGLE_ULONGLONG(0);
  clear_has_verifycode();
}
inline ::google::protobuf::uint64 UserLoginResponse::verifycode() const {
  return verifycode_;
}
inline void UserLoginResponse::set_verifycode(::google::protobuf::uint64 value) {
  set_has_verifycode();
  verifycode_ = value;
}

// optional string version = 5;
inline bool UserLoginResponse::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLoginResponse::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLoginResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLoginResponse::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UserLoginResponse::version() const {
  return *version_;
}
inline void UserLoginResponse::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UserLoginResponse::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void UserLoginResponse::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* UserLoginResponse::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 updateAble = 6;
inline bool UserLoginResponse::has_updateable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserLoginResponse::set_has_updateable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserLoginResponse::clear_has_updateable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserLoginResponse::clear_updateable() {
  updateable_ = 0;
  clear_has_updateable();
}
inline ::google::protobuf::int32 UserLoginResponse::updateable() const {
  return updateable_;
}
inline void UserLoginResponse::set_updateable(::google::protobuf::int32 value) {
  set_has_updateable();
  updateable_ = value;
}

// optional string fileServerAddress = 7;
inline bool UserLoginResponse::has_fileserveraddress() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLoginResponse::set_has_fileserveraddress() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserLoginResponse::clear_has_fileserveraddress() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserLoginResponse::clear_fileserveraddress() {
  if (fileserveraddress_ != &::google::protobuf::internal::kEmptyString) {
    fileserveraddress_->clear();
  }
  clear_has_fileserveraddress();
}
inline const ::std::string& UserLoginResponse::fileserveraddress() const {
  return *fileserveraddress_;
}
inline void UserLoginResponse::set_fileserveraddress(const ::std::string& value) {
  set_has_fileserveraddress();
  if (fileserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    fileserveraddress_ = new ::std::string;
  }
  fileserveraddress_->assign(value);
}
inline void UserLoginResponse::set_fileserveraddress(const char* value) {
  set_has_fileserveraddress();
  if (fileserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    fileserveraddress_ = new ::std::string;
  }
  fileserveraddress_->assign(value);
}
inline void UserLoginResponse::set_fileserveraddress(const char* value, size_t size) {
  set_has_fileserveraddress();
  if (fileserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    fileserveraddress_ = new ::std::string;
  }
  fileserveraddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_fileserveraddress() {
  set_has_fileserveraddress();
  if (fileserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    fileserveraddress_ = new ::std::string;
  }
  return fileserveraddress_;
}
inline ::std::string* UserLoginResponse::release_fileserveraddress() {
  clear_has_fileserveraddress();
  if (fileserveraddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fileserveraddress_;
    fileserveraddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 instance_id = 8;
inline bool UserLoginResponse::has_instance_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLoginResponse::set_has_instance_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserLoginResponse::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserLoginResponse::clear_instance_id() {
  instance_id_ = 0;
  clear_has_instance_id();
}
inline ::google::protobuf::int32 UserLoginResponse::instance_id() const {
  return instance_id_;
}
inline void UserLoginResponse::set_instance_id(::google::protobuf::int32 value) {
  set_has_instance_id();
  instance_id_ = value;
}

// optional string tempMailAddress = 9;
inline bool UserLoginResponse::has_tempmailaddress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserLoginResponse::set_has_tempmailaddress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserLoginResponse::clear_has_tempmailaddress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserLoginResponse::clear_tempmailaddress() {
  if (tempmailaddress_ != &::google::protobuf::internal::kEmptyString) {
    tempmailaddress_->clear();
  }
  clear_has_tempmailaddress();
}
inline const ::std::string& UserLoginResponse::tempmailaddress() const {
  return *tempmailaddress_;
}
inline void UserLoginResponse::set_tempmailaddress(const ::std::string& value) {
  set_has_tempmailaddress();
  if (tempmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    tempmailaddress_ = new ::std::string;
  }
  tempmailaddress_->assign(value);
}
inline void UserLoginResponse::set_tempmailaddress(const char* value) {
  set_has_tempmailaddress();
  if (tempmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    tempmailaddress_ = new ::std::string;
  }
  tempmailaddress_->assign(value);
}
inline void UserLoginResponse::set_tempmailaddress(const char* value, size_t size) {
  set_has_tempmailaddress();
  if (tempmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    tempmailaddress_ = new ::std::string;
  }
  tempmailaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_tempmailaddress() {
  set_has_tempmailaddress();
  if (tempmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    tempmailaddress_ = new ::std::string;
  }
  return tempmailaddress_;
}
inline ::std::string* UserLoginResponse::release_tempmailaddress() {
  clear_has_tempmailaddress();
  if (tempmailaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tempmailaddress_;
    tempmailaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 area_id = 10;
inline bool UserLoginResponse::has_area_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserLoginResponse::set_has_area_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserLoginResponse::clear_has_area_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserLoginResponse::clear_area_id() {
  area_id_ = 0;
  clear_has_area_id();
}
inline ::google::protobuf::int32 UserLoginResponse::area_id() const {
  return area_id_;
}
inline void UserLoginResponse::set_area_id(::google::protobuf::int32 value) {
  set_has_area_id();
  area_id_ = value;
}

// optional string bankServer = 11;
inline bool UserLoginResponse::has_bankserver() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserLoginResponse::set_has_bankserver() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserLoginResponse::clear_has_bankserver() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserLoginResponse::clear_bankserver() {
  if (bankserver_ != &::google::protobuf::internal::kEmptyString) {
    bankserver_->clear();
  }
  clear_has_bankserver();
}
inline const ::std::string& UserLoginResponse::bankserver() const {
  return *bankserver_;
}
inline void UserLoginResponse::set_bankserver(const ::std::string& value) {
  set_has_bankserver();
  if (bankserver_ == &::google::protobuf::internal::kEmptyString) {
    bankserver_ = new ::std::string;
  }
  bankserver_->assign(value);
}
inline void UserLoginResponse::set_bankserver(const char* value) {
  set_has_bankserver();
  if (bankserver_ == &::google::protobuf::internal::kEmptyString) {
    bankserver_ = new ::std::string;
  }
  bankserver_->assign(value);
}
inline void UserLoginResponse::set_bankserver(const char* value, size_t size) {
  set_has_bankserver();
  if (bankserver_ == &::google::protobuf::internal::kEmptyString) {
    bankserver_ = new ::std::string;
  }
  bankserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_bankserver() {
  set_has_bankserver();
  if (bankserver_ == &::google::protobuf::internal::kEmptyString) {
    bankserver_ = new ::std::string;
  }
  return bankserver_;
}
inline ::std::string* UserLoginResponse::release_bankserver() {
  clear_has_bankserver();
  if (bankserver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankserver_;
    bankserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string area_name = 12;
inline bool UserLoginResponse::has_area_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserLoginResponse::set_has_area_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserLoginResponse::clear_has_area_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserLoginResponse::clear_area_name() {
  if (area_name_ != &::google::protobuf::internal::kEmptyString) {
    area_name_->clear();
  }
  clear_has_area_name();
}
inline const ::std::string& UserLoginResponse::area_name() const {
  return *area_name_;
}
inline void UserLoginResponse::set_area_name(const ::std::string& value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void UserLoginResponse::set_area_name(const char* value) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void UserLoginResponse::set_area_name(const char* value, size_t size) {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginResponse::mutable_area_name() {
  set_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    area_name_ = new ::std::string;
  }
  return area_name_;
}
inline ::std::string* UserLoginResponse::release_area_name() {
  clear_has_area_name();
  if (area_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = area_name_;
    area_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .message.UserLoginResponse.AreaData areaDataList = 13;
inline int UserLoginResponse::areadatalist_size() const {
  return areadatalist_.size();
}
inline void UserLoginResponse::clear_areadatalist() {
  areadatalist_.Clear();
}
inline const ::message::UserLoginResponse_AreaData& UserLoginResponse::areadatalist(int index) const {
  return areadatalist_.Get(index);
}
inline ::message::UserLoginResponse_AreaData* UserLoginResponse::mutable_areadatalist(int index) {
  return areadatalist_.Mutable(index);
}
inline ::message::UserLoginResponse_AreaData* UserLoginResponse::add_areadatalist() {
  return areadatalist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::message::UserLoginResponse_AreaData >&
UserLoginResponse::areadatalist() const {
  return areadatalist_;
}
inline ::google::protobuf::RepeatedPtrField< ::message::UserLoginResponse_AreaData >*
UserLoginResponse::mutable_areadatalist() {
  return &areadatalist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_UserLogin_2eproto__INCLUDED
